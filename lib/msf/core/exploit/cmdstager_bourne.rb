# -*- coding: binary -*-
##
# $Id: cmdstager_bourne.rb
##

require 'msf/core/exploit/cmdstager'

module Msf

###
#
# This mixin provides an interface for staging cmd to arbitrary payloads
#
###
module Exploit::CmdStagerBourne

	include Msf::Exploit::CmdStager

	def initialize(info = {})
		super

		register_advanced_options(
			[
				OptEnum.new( 'DECODER',  [ false, 'The decoding binary to use', 'auto', ['auto', 'base64', 'openssl', 'python', 'perl']]),
			], self.class)
	end

	def create_stager(exe)
		Rex::Exploitation::CmdStagerBourne.new(exe)
	end

	def generate_cmdstager(opts = {}, pl = nil)
		available_decoders = ['base64', 'openssl', 'python', 'perl']
		opts.merge!({ :decoder => datastore['DECODER'] })

		if opts[:decoder] == 'auto'
			if self.respond_to? :execute_command_with_feedback
				available_decoders.each do |bin|
					which_result = execute_command_with_feedback("which #{bin}", opts).to_s
					which_result = which_result.strip
					if which_result.split.length == 1 and which_result.end_with?(bin)
						opts[:decoder] = bin
						break
					end
				end
			end

			if opts[:decoder] == 'auto'
				print_error("Could not detect an appropriate decoder, try setting the DECODER option")
				raise ArgumentError
			else
				print_status("Command Stager using auto-detected decoder: #{opts[:decoder]}")
			end
		end

		if not available_decoders.include?(opts[:decoder])
			print_error("Decoder must be one of #{available_decoders.join(', ')}")
			raise ArgumentError
		end
		super
	end
end

end
